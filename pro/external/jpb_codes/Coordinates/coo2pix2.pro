PRO coo2pix2,c1,c2,pixx,pixy,phi,theta, $	     silent=silent,projection=projection,lbl=lbl;+; NAME:;	coo2pix2; PURPOSE:;       converts coordinates to pixels for a certain projection; CATEGORY:;       Coordinates conversions; CALLING SEQUENCE:;	coo2pix2,c1,c2,pixx,pixy[,phi,theta]; INPUTS:;	c1,c2 (coordinates degrees); OPTIONAL INPUT PARAMETERS:; OUTPUTS:;	pixx        = x pixel value (IDL format);	pixy        = y pixel value (IDL format); OPTIONAL OUTPUT PARAMETERS:;	theta, phi  = native spherical coordinates; ACCEPTED KEY-WORDS:;	projection = set to force the proj type (otherwise from common);	silent     = for the program to be silent;	lbl        = line by line processing, to save memory space; COMMON BLOCKS:;	proj_common.com; SIDE EFFECTS:; RESTRICTIONS:; PROCEDURE:;	like coo2pix, but performs the calculation on the array at once;	(not line by line);	pixx and pixy are centered at the projection center;    sxpar,my_ll2uv,my_uv2ll,apply_proj2; EXAMPLES;    ; MODIFICATION HISTORY:;	Written by J.P. Bernard Mar 20 1995;    Modified JPB 8/7/99 to use non 2D coordinates arrays;    Modified JPB/HB 02/05/00 to deal with coo1<0 in the CAR case;    Modified JPB 14/07/00 to undo the above modification;-@proj_common.com;---------------------------------------------------------------; parameter check;---------------------------------------------------------------IF N_PARAMS(0) LT 4 THEN BEGIN  PRINT,'Calling Sequence: '  PRINT,'coo2pix2,c1,c2,pixx,pixy[,phi,theta]'  PRINT,'   (coordinates in degrees)'  PRINT,'Accepted Key words: ,projection=,/silent,/lbl'  GOTO, closingENDIFpixx=0.*c1 & pixy=pixx;pixx=fltarr(Nx,Ny) & pixy=fltarr(Nx,Ny)si=size(c1)IF NOT keyword_set(lbl) THEN BEGIN  IF proj NE 'CSC' THEN BEGIN    IF proj NE 'CAR' THEN BEGIN      my_wcssph2xy,c1,c2,pixv,piyv,ctype=[ctype1,ctype2], $           crval=[crval1,crval2]*!radeg,longpole=longpole,phi=phi,theta=theta;      ind=where(c1 GT 180.,count);      IF count NE 0 THEN BEGIN;        pixv(ind)=1.*crpix1+((c1(ind)-360.)/!radeg-crval1)/cdelt1;      ENDIF      pixx=pixv/cdelt1/!radeg+crpix1      pixy=piyv/cdelt2/!radeg+crpix2    ENDIF ELSE BEGIN      pixv=(c1/!radeg-crval1)/cdelt1+crpix1      piyv=(c2/!radeg-crval2)/cdelt2+crpix2;     The following was for coordinates with range from -180 to 180 degree      crv1=crval1      IF crv1*!radeg GT 180. THEN crv1=crv1-360./!radeg      ind=where(c1 GT 180.,count)      IF count NE 0 THEN BEGIN        pixv(ind)=1.*crpix1+((c1(ind)-360.)/!radeg-crv1)/cdelt1      ENDIF      pixx=pixv & pixy=piyv    ENDELSE  ENDIF ELSE BEGIN    face=1    wcssph2xy,c1,c2,pixv,piyv,ctype=[ctype1,ctype2,'CUBEFACE'], $           crval=[crval1,crval2]*!radeg,face=face,longpole=longpole    Nyy=NAXIS2 & Nxx=NAXIS1    IF 3*Nyy EQ 2*Nxx THEN BEGIN ;Sixpack      cube_side=Nxx/3      offx=[2,2,1,0,0,1]      offy=[1,0,0,0,1,1]    ENDIF ELSE IF 4*Nyy EQ 3*Nxx THEN BEGIN ;T assumed Right      cube_side=Nxx/4      offx=[3,3,2,1,0,3]      offy=[2,1,1,1,1,0]    ENDIF ELSE BEGIN      print,'h2pix:input header does not match a cube'      goto,closing    ENDELSE    reso=ROUND(ALOG(cube_side)/ALOG(2))+1         ;e.g. Npix/face=n=2^(reso-1)    debx=offx*cube_side    finx=debx+cube_side-1    centx=1.*debx+1.*(finx-debx)/2.    deby=offy*cube_side    finy=deby+cube_side-1    centy=1.*deby+1.*(finy-deby)/2.;    stop    FOR ff=0,5 DO BEGIN      ind=where(face EQ ff,count)      IF count NE 0 THEN BEGIN        pixx(ind)=-pixv(ind)*cube_side/90.+centx(ff)        pixy(ind)=piyv(ind)*cube_side/90.+centy(ff)      ENDIF    ENDFOR  ENDELSE  IF si(0) EQ 0 THEN BEGIN    pixx=pixx(0) & pixy=pixy(0)  ENDIFENDIF ELSE BEGIN  IF si(0) EQ 2 THEN BEGIN    Nx=si(1) & Ny=si(2)  ENDIF ELSE BEGIN    message,'/lbl option only allowed for 2D arrays'  ENDELSE  pixv=c1 & piyv=pixv  phi=c1 & theta=phi  IF proj NE 'CSC' THEN BEGIN    IF proj NE 'CAR' THEN BEGIN      FOR j=0,Ny-1 DO BEGIN        my_wcssph2xy,c1(*,j),c2(*,j),pix,piy,ctype=[ctype1,ctype2], $         crval=[crval1,crval2]*!radeg,longpole=longpole,phi=pphi,theta=ttheta;     The following was for coordinates with range from -180 to 180 degree;      ind=where(c1(*,j) GT 180.,count);      IF count NE 0 THEN BEGIN;        pix(ind)=1.*crpix1+((c1(ind,j)-360.)/!radeg-crval1)/cdelt1;      ENDIF               phi(*,j)=pphi & theta(*,j)=ttheta      pixv(*,j)=pix & piyv(*,j)=piy      ENDFOR      pixx=pixv/cdelt1/!radeg+crpix1      pixy=piyv/cdelt2/!radeg+crpix2    ENDIF ELSE BEGIN      FOR j=0,Ny-1 DO BEGIN;        pixv(*,j)=c1(*,j)-crval1*!radeg;        piyv(*,j)=c2(*,j)-crval2*!radeg        pix=(c1(*,j)/!radeg-crval1)/cdelt1+crpix1        piy=(c2(*,j)/!radeg-crval2)/cdelt2+crpix2;       The following was for coordinates with range from -180 to 180 degree        crv1=crval1        IF crv1*!radeg GT 180. THEN crv1=crv1-360./!radeg        ind=where(c1(*,j) GT 180.,count)        IF count NE 0 THEN BEGIN          pix(ind)=1.*crpix1+((c1(ind,j)-360.)/!radeg-crv1)/cdelt1        ENDIF                 pixv(*,j)=pix & piyv(*,j)=piy      ENDFOR      pixx=pixv & pixy=piyv    ENDELSE  ENDIF ELSE BEGIN    Nyy=NAXIS2 & Nxx=NAXIS1    IF 3*Nyy EQ 2*Nxx THEN BEGIN ;Sixpack      cube_side=Nxx/3      offx=[2,2,1,0,0,1]      offy=[1,0,0,0,1,1]    ENDIF ELSE IF 4*Nyy EQ 3*Nxx THEN BEGIN ;T assumed Right      cube_side=Nxx/4      offx=[3,3,2,1,0,3]      offy=[2,1,1,1,1,0]    ENDIF ELSE BEGIN      print,'h2pix:input header does not match a cube'      goto,closing    ENDELSE    reso=ROUND(ALOG(cube_side)/ALOG(2))+1         ;e.g. Npix/face=n=2^(reso-1)    debx=offx*cube_side    finx=debx+cube_side-1    centx=1.*debx+1.*(finx-debx)/2.    deby=offy*cube_side    finy=deby+cube_side-1    centy=1.*deby+1.*(finy-deby)/2.    FOR j=0,Ny-1 DO BEGIN      face=1      wcssph2xy,c1(*,j),c2(*,j),pixv,piyv,ctype=[ctype1,ctype2,'CUBEFACE'], $           crval=[crval1,crval2]*!radeg,face=face,longpole=longpole      FOR ff=0,5 DO BEGIN        ind=where(face EQ ff,count)        IF count NE 0 THEN BEGIN          pixx(ind,j)=pixv(ind)*cube_side*90.+centx(ff)          pixy(ind,j)=piyv(ind)*cube_side*90.+centy(ff)        ENDIF      ENDFOR    ENDFOR  ENDELSEENDELSEclosing:END
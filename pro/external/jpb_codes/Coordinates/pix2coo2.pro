PRO pix2coo2,pixv,piyv,coo1,coo2,phi,theta, $	     silent=silent,projection=projection,lbl=lbl,face=face, $	     one_eighty=one_eighty;+; NAME:;	pix2coo2; PURPOSE:;       converts pixels to coordinates given projection parameters; CATEGORY:;       Coordinates conversions; CALLING SEQUENCE: ;	pix2coo2,pixx,pixy,coo1,coo2; INPUTS:;	pixx= x pixel value (IDL format);	pixy= y pixel value (IDL format); OPTIONAL INPUT PARAMETERS:; OUTPUTS:;	coo1,coo2 (degrees); OPTIONAL OUTPUT PARAMETERS:; ACCEPTED KEY-WORDS:;	projection= set to force the proj type (otherwise from proj_common);	silent  = for the program to be silent;	lbl      = line by line (to avoid out of memory pbs);    one_eighty = if set longitude are -180<coo1<180; COMMON BLOCKS:; SIDE EFFECTS:; RESTRICTIONS:; PROCEDURE:;    sxpar, apply_proj2, my_uv2ll, my_ll2uv; MODIFICATION HISTORY:;	Written by J.P. Bernard Mar 20 1995;    Modified JPB 8/7/99 to use non 2D coordinates arrays;    Modified JPB/HB 2/5/00 fixed a bug with phi,theta when lbl=1;                           set so that 0<coo1<360 is the default;    Modified JPB 28/05/02 to fix a bug for right Tee CSC;    Added phi=coo1 & theta=coo2 for CAR projection;-@proj_common.com;---------------------------------------------------------------; parameter check;---------------------------------------------------------------IF N_PARAMS(0) LT 4 THEN BEGIN  PRINT,'Calling Sequence: '  PRINT,'pix2coo2,pixx,pixy,coo1,coo2[,phi,theta]'  PRINT,'   (coordinates in degrees)'  PRINT,'Accepted Key words: ,projection=,/silent,/lbl'  GOTO, closingENDIFIF proj EQ 'CSC' THEN BEGIN  Nyy=NAXIS2 & Nxx=NAXIS1  face=pixv  face(*)=!indef  IF 3*Nyy EQ 2*Nxx THEN BEGIN ;assumed to be sixpack format    cube_side=Nxx/3    offx=[2,2,1,0,0,1]    offy=[1,0,0,0,1,1]  ENDIF ELSE IF 4*Nyy EQ 3*Nxx THEN BEGIN    cube_side=Nxx/4    CASE cubetype OF      'RIGHTTEE': BEGIN        offx=[3,3,2,1,0,3]        offy=[2,1,1,1,1,0]      END      'TEE': BEGIN        offx=[2,2,1,0,3,2]        offy=[2,1,1,1,1,0]            END      ELSE : BEGIN  ;!assummed tee        offx=[2,2,1,0,3,2]        offy=[2,1,1,1,1,0]            END    ENDCASE  ENDIF ELSE BEGIN    print,'h2pix:input header does not match a cube'    goto,closing  ENDELSE  reso=ROUND(ALOG(cube_side)/ALOG(2))+1         ;e.g. Npix/face=n=2^(reso-1)  debx=offx*cube_side  finx=debx+cube_side-1  centx=1.*debx+1.*(finx-debx)/2.  deby=offy*cube_side  finy=deby+cube_side-1  centy=1.*deby+1.*(finy-deby)/2.  ;Determine to which face pixels belong  pixx=pixv & pixy=piyv  FOR ff=0,5 DO BEGIN    ind=where(pixv GE debx(ff) AND pixv LE finx(ff) AND $                piyv GE deby(ff) AND piyv LE finy(ff),count)    IF count NE 0 THEN BEGIN      face(ind)=ff      pixx(ind)=-(pixv(ind)-centx(ff))/cube_side*90.      pixy(ind)= (piyv(ind)-centy(ff))/cube_side*90.    ENDIF  ENDFOR  ctype=[ctype1,ctype2,'CUBEFACE']  crval=[crval1,crval2]*!radeg;  stopENDIF ELSE BEGIN  pixx=(pixv-crpix1)*cdelt1*!radeg		;in degrees from crpix  pixy=(piyv-crpix2)*cdelt2*!radeg  ctype=[ctype1,ctype2]  crval=[crval1,crval2]*!radeg			;in degreesENDELSEsi=size(pixx);stop;Compute the coordinatesIF proj EQ 'CSC' THEN BEGIN  coo1=1.*pixv & coo2=1.*piyv  coo1(*)=!indef & coo2(*)=!indef  IF NOT keyword_set(lbl) THEN BEGIN    ind=where(face NE !indef,count)    IF count NE 0 THEN BEGIN      my_wcsxy2sph,pixx(ind),pixy(ind),c1,c2,ctype=ctype,crval=crval,face=face(ind), $              longpole=longpole,projp1=projp1      coo1(ind)=c1 & coo2(ind)=c2    ENDIF  ENDIF ELSE BEGIN    IF si(0) EQ 2 THEN BEGIN      Nx=si(1) & Ny=si(2)    ENDIF ELSE BEGIN      message,'/lbl option only allowed for 2D arrays'    ENDELSE    FOR j=0,Ny-1 DO BEGIN      ind=where(face(*,j) NE !indef,count)      IF count NE 0 THEN BEGIN        my_wcsxy2sph,pixx(ind,j),pixy(ind,j),c1,c2,ctype=ctype,crval=crval, $                face=face(ind,j),longpole=longpole,projp1=projp1        coo1(ind,j)=c1 & coo2(ind,j)=c2      ENDIF    ENDFOR  ENDELSEENDIF ELSE BEGIN  IF NOT keyword_set(lbl) THEN BEGIN    IF proj NE 'CAR' THEN BEGIN ;     stop      my_wcsxy2sph,pixx,pixy,coo1,coo2,ctype=ctype,crval=crval,face=face, $                longpole=longpole,projp1=projp1,phi=phi,theta=theta    ENDIF ELSE BEGIN      coo1=pixx+crval1*!radeg      coo2=pixy+crval2*!radeg;      coo1=((pixx-crpix1)*cdelt1+crval1)*!radeg;      coo2=((pixy-crpix2)*cdelt2+crval2)*!radeg      coo1=[coo1]      ind=where(coo1 LE 0. AND coo1 NE !indef,count)      IF count NE 0 THEN coo1(ind)=coo1(ind)+360.      phi=coo1 & theta=coo2    ENDELSE  ENDIF ELSE BEGIN    IF si(0) EQ 2 THEN BEGIN      Nx=si(1) & Ny=si(2)    ENDIF ELSE BEGIN      message,'/lbl option only allowed for 2D arrays'    ENDELSE    coo1=fltarr(Nx,Ny) & coo2=fltarr(Nx,Ny)    phi=fltarr(Nx,Ny)    theta=fltarr(Nx,Ny)    IF proj NE 'CAR' THEN BEGIN      FOR j=0,Ny-1 DO BEGIN        phii=1 & thee=1        my_wcsxy2sph,pixx(*,j),pixy(*,j),c1,c2,ctype=ctype,crval=crval, $                  face=face,longpole=longpole,projp1=projp1,phi=phii,theta=thee        coo1(*,j)=c1 & coo2(*,j)=c2        phi(*,j)=phii        theta(*,j)=thee      ENDFOR    ENDIF ELSE BEGIN      FOR j=0,Ny-1 DO BEGIN        coo1(*,j)=pixx(*,j)+crval1*!radeg        coo2(*,j)=pixy(*,j)+crval2*!radeg        coo1=[coo1]        ind=where(coo1 LE 0. AND coo1 NE !indef,count)        IF count NE 0 THEN coo1(ind)=coo1(ind)+360.      ENDFOR      phi=coo1 & theta=coo2    ENDELSE  ENDELSEENDELSEIF keyword_set(one_eighty) THEN BEGIN  ind=where(coo1 GT 180. AND coo1 NE !indef,count)  IF count NE 0 THEN coo1(ind)=coo1(ind)-360.ENDIFIF si(0) EQ 0 THEN BEGIN  coo1=coo1(0)ENDIFRETURNclosing:END